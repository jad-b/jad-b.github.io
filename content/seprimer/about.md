+++
categories = ["software engineering primer"]
date = "2016-12-17T11:41:37-05:00"
tags = ["software engineering"]
title = "about"

+++
## The Motivation For This Book
This book aims to provide Software Engineers with sensible, modern defaults for
for delivering high-quality software. It goes further in that it also tries to
_teach_ the process behind arriving at these decisions, enabling engineers to
start with the suggestions in this book, modify them in the light of real-life
situations, and arrive at the optimal outcome.

Develop as an engineer, produce superior work, and save time along the way - not
bad for reading sequences of words that we collectively made-up out of also
made-up symbols. Kind of amazing any of this works, actually. But I digress.

## Who Should Read This Book
Junior-ish engineers, by which I'll define as having less than five years
experience, will probably get the most out of this book. This is assuming that
this engineer is destined for greatness anyway, and that giving them missing
information gives them a jump on the path before them.

TODO: Building a house

That said, lets interpolate the ideal case to the common. Anyone who feels like
they've stagnated in their development, perhaps from a less-than-modern development
culture, could benefit from _parts_ of the book. Get your logging standards
up-to-par, or base your team's pre-deployment security checklist off of the one
here. Notice I said "base" - this book provides sensible defaults, with the
rationale that you

## What this book is *not*
This book does not to teach you how to program. It assumes you know how to
program, or are actively learning to _right now_. If the phrase "functions are
not first-class citizens in Java" doesn't hold meaning, you will have trouble.
This book does not attempt to determine what a formal education for a "Software
Engineer" is - you'd be thinking of [this
book](http://sites.computer.org/ccse/SE2004Volume.pdf). And you can keep that
book to yourself. Nobody here wants to talk about that book.

# How to Read this Book
If you are new to the field, and you find yourself wondering on how to quickly
get up to speed and contributing professional-level work, I suggest quickly
reading through the entire book. Pay particular attention to the Key Insights at
the front of each chapter, and largely ignore any of the specific details. Also,
print out, or at least take note of, the checklists. Then, as you go about your
job, open up the pertinent section and pair-program with this book in hand.
Tasked with writing the deployment for the team's microservice? Flip to
"Delivery", and proceed.

For those who feel comfortable in their work (perhaps dangerously so, hmmmm?), I
suggest scanning down the table of contents for interesting sections, and
dipping in where the whim or need takes you.

If you're starting a greenfield project (that means "brand-new"), and you want
to apply these principles from the get-go, then check out the Roadmap in the
back of the book. This is _a_ way of checking all the boxes.

## Assumptions and Biases
I write from the perspective of a junior-becoming-intermediate engineer. I
started coding in 2011, and I started figuring out how to _engineer software_
when I got my first job in 2014. Turns out there's a lot a CS degree doesn't
teach you when it comes to actually making software people can happily use and
easily maintain. Like everyone else, I cobbled together knowledge through
trial-and-error, code reviews, and Stack Overflow. I learn well from books, so I
also bought a number of them to learn from as well. Over time, ideas started to
come together.

I assume you either have deployed, or are trying to deploy, working software for a
customer, whether that be yourself or someone who actually is giving you money.
Thus, I assume you can write software in the first place - this book will _not_
attempt to bring you up to speed with the basics of programming. Little here is
what I would dare to call advanced, if only because calling what's
presented here "advanced" leaves nothing to describe truly difficult concepts in
this world. But I've not shyed from including interesting design patterns or
techniques where called for, and if they confuse you a little at first, good.
That means you're learning something. If it wasn't confusing, you already
understood it, and you're just collecting information.
